/* $Id: loadscreen.cpp 47608 2010-11-21 01:56:29Z shadowmaster $ */
/*
   Copyright (C) 2005 - 2010 by Joeri Melis <joeri_melis@hotmail.com>
   Part of the Battle for Wesnoth Project http://www.wesnoth.org/

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY.

   See the COPYING file for more details.
*/

/**
 * @file
 * Screen with logo and "Loading ..."-progressbar during program-startup.
 */
#define GETTEXT_DOMAIN "rose-lib"

#include "loadscreen.hpp"

#include "font.hpp"
#include "marked-up_text.hpp"
#include "gettext.hpp"
#include "filesystem.hpp"
#include "video.hpp"
#include "image.hpp"
#include "wml_exception.hpp"
#include "rose_config.hpp"

#include <SDL_events.h>
#include <SDL_image.h>

#include <cassert>

loadscreen::global_loadscreen_manager* loadscreen::global_loadscreen_manager::manager = 0;

loadscreen::global_loadscreen_manager::global_loadscreen_manager(CVideo& screen)
  : owns(global_loadscreen == 0)
{
	if(owns) {
		manager = this;
		global_loadscreen = new loadscreen(screen);
		global_loadscreen->clear_screen();
	}
}

loadscreen::global_loadscreen_manager::~global_loadscreen_manager()
{
	reset();
}

void loadscreen::global_loadscreen_manager::reset()
{
	if(owns) {
		owns = false;
		manager = 0;
		assert(global_loadscreen);
		// global_loadscreen->clear_screen();
		delete global_loadscreen;
		global_loadscreen = 0;
	}
}

static surface scaled_logo_surface;

loadscreen::loadscreen(CVideo &screen, const int &percent):
	screen_(screen),
	textarea_(),
	logo_surface_(image::get_image(game_config::logo_png)),
	logo_drawn_(false),
	pby_offset_(0),
	prcnt_(percent)
{
	if (logo_surface_.null()) {
		// loadscreen: Failed to load the logo
	}
	textarea_.x = textarea_.y = textarea_.w = textarea_.h = 0;
}

void loadscreen::draw_screen(const std::string &text)
{
	return;
}

void loadscreen::clear_screen()
{
	return;
}

loadscreen *loadscreen::global_loadscreen = 0;

struct load_stage
{
	char const *id;
	char const *name;
	int start_pos, max_count;
};

static int const nb_stages = 20;

/**
 * Description of all the stages.
 * @note Some of the stages appear twice; this is not a mistake. It
 *       accounts for their cost at title time and at game time.
 * @note The values have been automatically generated by running a cache-hot
 *       Wesnoth on HttH with the --log-info=loadscreen option.
 */
static load_stage const stages[nb_stages] =
{
	{ "init gui", "Initializing user interface", 0, 17210 },
	{ "load config", "Loading game configuration", 20, 0 },
	{ "verify cache", "Verifying cache", 20, 164 },
	{ "create cache", "Reading files and creating cache", 21, 80287 },
	{ "load unit types", "Reading unit files", 94, 467 },
	{ "init fonts", "Re-initialize fonts for the current language", 98, 17 },
	{ "refresh addons", "Searching for installed add-ons", 99, 0 },
	{ "titlescreen", "Loading title screen", 100, 0 },
	{ "load data", "Loading data files", 0, 0 },
	{ "verify cache", "Verifying cache", 0, 0 },
	{ "create cache", "Reading files and creating cache", 0, 152109 },
	{ "load unit types", "Reading unit files", 74, 488 },
	{ "load level", "Loading level", 75, 0 },
	{ "init teams", "Initializing teams", 75, 0 },
	{ "load units", "Loading units", 77, 0 },
	{ "init scene", "Initializing display", 77, 0 },
	{ "build terrain", "Building terrain rules", 77, 1240 },
	{ "init display", "Initializing display", 90, 0 },
	{ "draw scene", "Drawing scene", 95, 0 },
	{ "start game", "Starting game", 100, 0 },
};

static int current_stage;
static int stage_counter[nb_stages];
static unsigned stage_time[nb_stages];

void loadscreen::start_stage(char const *id)
{
	assert(global_loadscreen);

	int s = -1;
	for (int i = 0; i < nb_stages; ++i) {
		int j = (i + current_stage) % nb_stages;
		if (strcmp(id, stages[j].id) == 0) {
			s = j;
			break;
		}
	}

	std::stringstream str;
	str << "unknown stage id: " << id;
	VALIDATE(s >= 0, str.str());

	const load_stage &cs = stages[s];
	global_loadscreen->prcnt_ = cs.start_pos;
	global_loadscreen->draw_screen(_(cs.name));
	stage_counter[s] = 0;
	stage_time[s] = SDL_GetTicks();
	current_stage = s;
}

void loadscreen::increment_progress()
{
	if (!global_loadscreen) return;

	int v = ++stage_counter[current_stage];
	int m = stages[current_stage].max_count;
	if (v > m) return;

	int s = stages[current_stage].start_pos;
	int percentage = s + v * (stages[current_stage + 1].start_pos - s) / m;
	if (percentage == global_loadscreen->prcnt_) return;

	global_loadscreen->prcnt_ = percentage;
	global_loadscreen->draw_screen(std::string());
}

void loadscreen::dump_counters() const
{
	return;

	std::ostringstream s;

	int i = 0;
	while (i < nb_stages)
	{
		int j;
		for (j = i; stages[j].start_pos < 100; ++j) {}
		if (stage_time[i] == stage_time[j]) break;
		for (int k = i; k <= j; ++k)
		{
			int v = stages[k].start_pos;
			if (i < k && k < j) {
				v = stages[i].start_pos +
					(100 - stages[i].start_pos) *
					(stage_time[k] - stage_time[i]) /
					(stage_time[j] - stage_time[i]);
			}
			s << "\t{ \"" << stages[k].id << "\", N_(\""
			  << stages[k].name << "\"), " << v << ", "
			  << stage_counter[k] << " },\n";
		}
		i = j + 1;
	}
	// Suggested loadscreen values:--- $s.str() ---
}


set_increment_progress::fn_increment_progress set_increment_progress::increment_progress = NULL;
void* set_increment_progress::ctx = NULL;

set_increment_progress::set_increment_progress(fn_increment_progress fn, void* ctx) :
	old_(increment_progress)
{
	set_increment_progress::increment_progress = fn;
	set_increment_progress::ctx = ctx;
}

set_increment_progress::~set_increment_progress()
{
	set_increment_progress::increment_progress = old_;
}

void increment_preprocessor_progress(std::string const &name, bool is_file)
{
	if (set_increment_progress::increment_progress) {
		set_increment_progress::increment_progress(name, is_file, set_increment_progress::ctx);
	}
}
